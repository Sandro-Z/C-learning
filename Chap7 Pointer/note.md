# 指针
## “&”运算符
作用：取得变量地址，必须操作变量
## 指针
`int* p` 或者 `int *p`，星号靠近谁都可以

`int* p,q`中，q是一个普通的int变量。故*是用于修饰变量的。

普通变量存放实际值，指针变量存放有实际值变量的地址。

* 函数传入指针参数：传入普通参数只能传入值，而传入某个变量的指针赋予了函数对该变量访问（读写）的能力。

* 关于读写：“*”，单目运算符，`*（变量）`表示括号内变量所代表地址上的变量，做右值读取，左值操作。(取得地址对应变量)

总之，&和*为逆运算，&i为i的指针，*p为指针变量p指向的变量。

* 任何指针没有被赋值之前不能通过其访问任何变量

### 指针的应用
* 交换
```
int swap(*pa,*pb){
    int temp=*pa;
    *pa=*pb;
    *pb=temp;
}
```

* 函数返回不止一个值，通过修改指针方式修改其他变量

## 传入函数的数组
函数参数表中的数组其实质是指针，写成指针也可以，同时可以使用方括号运算符进行运算。

* 数组变量就是特殊的指针，无需使用`&`取地址。

* 但是数组中的元素是普通变量，需要用`&`取地址。

* `[]`可以对指针做，`*`也可以对数组做。

数组变量是常量指针，不能被赋值。

## 指针和const
* `int * const q=<value>`（const在*的后面）：指针是常量，一旦指定不能再指向别的变量，但是指向的变量可以修改

* `const int *q=p`或者`int const *q=p`（const在*的前面）：指针和指向的变量都可以改变值，但是不能通过q去改变p

避免函数通过指针对外部变量做修改，同时可以传递较大对象

* const数组：每个元素都是const，必须赋初值

## 指针运算
* 指针变量加1的时候，其值增加`sizeof(指向的变量)`

* 指针可以做加减，自增自减，但是对于不储存在连续空间的变量没有任何意义

* 两个指针可以相减，结果为`<两指针相减的值>/sizeof(元素)`

* `*p++`：取出指针所指值，顺便把p移到下一个位置，适合遍历

* 指针可以比较大小，数组内的元素的指针肯定是连续递增的

* 指向不同类型的指针是不能互相赋值的，避免用错指针
## 动态内存分配
如果开始指定可变的数组的大小，C99之前应写为：

`a=(int*)malloc(<指定数组的大小>*sizeof(int))`

此时a可以当作普通的数组来用。

在用完该组合数据后，使用`free(a)`释放空间。

* 只有malloc函数分配的空间才可以用`free()`释放。